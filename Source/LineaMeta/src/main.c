#include <string.h>
#include <esp_timer.h>

#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"

#include "sdkconfig.h" // generated by "make menuconfig"
#include "ssd1366.h"

#include <esp_adc/adc_continuous.h>
#include "adc.h"
#include "buttons.h"

static const char * TAG = "MAIN";


adc_channel_t channels[1] = { ADC_CHANNEL_3 };
adc_continuous_handle_t adcHandle;

TaskHandle_t adcTask;
QueueHandle_t adcDataQueue;

#define ADC_THRESHOLD 3000

typedef enum ADC_MESSAGE{
	ADC_TRIGGERED = 0, // When signal crosses the threshold.
	ADC_FALLING
} ADC_MESSAGE;

typedef enum ADC_STATE{
	ADC_WAITING = 0, // Waiting for shadow.
	ADC_ARMED,       // First shadow detected
	ADC_FALLEN,	     // Adc is bright again
} ADC_STATE;

uint64_t message;

void taskAdcFunction()
{
	uint8_t result[20*SOC_ADC_DIGI_DATA_BYTES_PER_CONV];
	uint32_t resultLen =0;
	ADC_MESSAGE toSendMessage;
	uint32_t singleData = 0;
	uint64_t proposedTime = 0;
	ADC_STATE state = ADC_WAITING;

	while(1)
	{
		adc_continuous_read(adcHandle, result, 20*SOC_ADC_DIGI_DATA_BYTES_PER_CONV, &resultLen, 3000);
		for (int i = 0; i < resultLen; i += SOC_ADC_DIGI_RESULT_BYTES) {
			adc_digi_output_data_t *p = (adc_digi_output_data_t*)&result[i];
			// p->type2.data;
			singleData = p->type2.data;

			if(state ==	ADC_WAITING)
			{
				if( singleData > ADC_THRESHOLD)
				{
					state = ADC_ARMED;
				}
			}else if ( state == ADC_ARMED )
			{
				if( singleData < ADC_THRESHOLD)
				{
					proposedTime = esp_timer_get_time();
					state = ADC_FALLEN;
				}
			}
			else if (state == ADC_FALLEN)
			{
				if ( singleData > ADC_THRESHOLD)
				{
					state = ADC_ARMED;
				}
			}

		}
		if (state == ADC_FALLEN && esp_timer_get_time() - proposedTime > 100000)
		{
			xQueueSend(adcDataQueue, (void*) &proposedTime, portMAX_DELAY);
			state = ADC_WAITING;
		}
		vTaskDelay(1);
	}
}


void app_main(void)
{

	// Freertos things
	adcDataQueue = xQueueCreate(1, sizeof(uint64_t));


	continuous_adc_init(channels, 1, &adcHandle);
	


	//adc_continuous_read(adcHandle, result, 20*SOC_ADC_DIGI_DATA_BYTES_PER_CONV, &resultLen, 3000);

	ESP_LOGE(TAG, "Hola mundo!");
	i2c_master_init();
	ssd1306_init();
	buttons_init(GPIO_NUM_9, GPIO_NUM_10);


	task_ssd1306_display_clear(NULL);
	vTaskDelay(100/portTICK_PERIOD_MS);
	task_ssd1306_display_text((void*)"GluonGP Timer", 0);

	char timeStr[64];
	uint32_t cnt = 0;
	uint32_t data = 0;
	uint8_t b1,b2;

	xTaskCreate(taskAdcFunction, "Adc_Task", 4096, NULL, 9, &adcTask);
	uint32_t receivedMessage;

	uint64_t lastTimeStamp = esp_timer_get_time();
	uint32_t deltaTime = 0;

	float trackDistance = 5476.192f;

	while( 1 )
	{

		/*adc_continuous_read(adcHandle, result, 20*SOC_ADC_DIGI_DATA_BYTES_PER_CONV, &resultLen, 3000);

		for (int i = 0; i < resultLen; i += SOC_ADC_DIGI_RESULT_BYTES) {
			adc_digi_output_data_t *p = (adc_digi_output_data_t*)&result[i];
			data += p->type2.data;
		}
		data = data/resultLen;*/
		xQueueReceive( adcDataQueue, &receivedMessage, portMAX_DELAY );
		//printf("Desde main!\n");
		deltaTime = (uint32_t)(receivedMessage-lastTimeStamp)/1000;

		sprintf(timeStr, "Time: %.3f  ", (float)deltaTime/1000.0f);

		lastTimeStamp = receivedMessage;
		task_ssd1306_display_text(timeStr, 2);

		sprintf(timeStr, "Speed: %.3f  ", (float)trackDistance/deltaTime);
		task_ssd1306_display_text(timeStr, 4);

		/*buttons_getStatus(&b1, &b2);
		if(b1){
			sprintf(timeStr, "Time: %ld  ", data);
		}else{
			sprintf(timeStr, "BBB : %ld  ", data);
		}*/
		//task_ssd1306_display_text(timeStr, 3);
		//vTaskDelay(pdMS_TO_TICKS(300));
	}
}